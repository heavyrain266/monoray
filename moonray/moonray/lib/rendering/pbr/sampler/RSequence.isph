// Copyright 2023-2024 DreamWorks Animation LLC
// SPDX-License-Identifier: Apache-2.0


#pragma once

#include <scene_rdl2/render/util/BitUtils.isph>

#include "hash.isph"
#include "Moebius.hh"
#include "Sample.isph"

const uniform float sqrt_pi = 1.772453850905516027298167f;

inline varying float mod1(varying float x)
{
    return x - floor(x);
}

inline uniform float mod1(uniform float x)
{
    return x - floor(x);
}

inline varying uint32_t rotate16(varying uint32_t n)
{
    return (n << 16u) | (n >> 16u);
}

inline uniform uint32_t rotate16(uniform uint32_t n)
{
    return (n << 16u) | (n >> 16u);
}

inline varying Sample2D randomPoint(varying uint32_t i)
{
    varying Sample2D result;
    result.u = bitsToFloat(useHighOrderBits(triple32inc(i)));
    result.v = bitsToFloat(useHighOrderBits(triple32inc(rotate16(i))));
    return result;
}

inline uniform Sample2D randomPoint(uniform uint32_t i)
{
    uniform Sample2D result;
    result.u = bitsToFloat(useHighOrderBits(triple32inc(i)));
    result.v = bitsToFloat(useHighOrderBits(triple32inc(rotate16(i))));
    return result;
}

// From http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences
// The unreasonable effectiveness of quasi-random sequences
// Martin Roberts
inline varying Sample2D sampleR2(varying uint32_t i)
{
    // We define g as the generalized version of the golden ratio in d dimensions as the unique positive root
    // x^(d + 1) = x + 1
    // Here we're in 2 dimensions.
    const uniform float g = 1.324717957244746f; // special math constant
    varying Sample2D a;
    a.u = 1.0f/g;
    a.v = 1.0f/(g*g);

    varying Sample2D result;
    result.u = mod1(a.u * (i + 1));
    result.v = mod1(a.v * (i + 1));
    return result;
}

// From http://extremelearning.com.au/a-simple-method-to-construct-isotropic-quasirandom-blue-noise-point-sequences/
// A simple method to construct isotropic quasi-random blue noise point sequences
// Martin Roberts
inline varying Sample2D jitteredR2(varying uint32_t n, varying uint32_t scramble)
{
    const uniform float lambda = 0.4f; // User parameter: the larger the value the more random jitter
    const uniform float delta = 0.76f; // Empirically optimized parameter

    // To jitter a point in the Fibonacci lattice of N points, you can offset the points as below:
    // p_i(x, y) + epsilon_i(delta_0/sqrt(N))
    // where delta_0 =~ 0.78
    // The author comes to the following value of i0 value by taking the mapping of two random variables to a disk of
    // radius r: epsilon_i(r) = (r*sqrt(u1) * cos(2*pi*u2), r*sqrt(ui) * sin(2*pi*u2))
    // With the coefficient of 1/sqrt(N) above, the author asserts that an infinite sequence can be substituted as
    // follows:
    // 1/sqrt(N) -> 1/(2 * sqrt(i - i0)), where i0 = 0.700 for i > 0
    // However, we're using zero-based indexing. Let
    // n = i - 1
    // Therefore
    // i - i0 = (n + 1) - i0 = n + (1 - i0)
    // Let n0 = 1 - i0
    // Taking n in [0, inf) leads to 1/(2 * sqrt(n + n0))
    const uniform float i0 = 0.700f; // Special math constant
    const uniform float n0 = 1.0f - i0;

    const varying Sample2D p = sampleR2(n);
    const varying Sample2D u = randomPoint(n + scramble);

    const varying float k = lambda * delta * sqrt_pi/(4.0f * sqrt(n + n0));
    const varying Sample2D j = Sample2D_init(k*u.u, k*u.v);
    const varying Sample2D result = Sample2D_init(mod1(p.u + j.u), mod1(p.v + j.v));

    return result;
}

// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/
inline varying float jitteredR1(varying uint32_t i, varying uint32_t scramble)
{
    const uniform float lambda = 0.4f; // User parameter: the larger the value the more random jitter

    // Guessed parameter: TODO: we should do an analysis as done for 2D points here:
    // http://extremelearning.com.au/a-simple-method-to-construct-isotropic-quasirandom-blue-noise-point-sequences/
    const uniform float delta = 0.26f;
    const uniform float i0 = 1.010f;

    // We want three scramble values: the starting offset (s0), the hash index, and our random value. We could pass in
    // three separate values, but I worry about correlation since the hash values will be generated by the same sequence
    // identifier and the same hash function. Here we're still using the same initial value, but our hash functions are
    // at least unique. I am not worried about loss of precision in the floating point values (notably in s0), as these
    // only serve to add some additional randomness.
    const varying uint16_t scramble0 = scramble & 0xFFFFu;
    const varying uint16_t scramble1 = (scramble >> 16u) & 0xFFFFu;

    const varying uint32_t idx = hash16_s6(scramble1) % kMoebiusTransformationSize;
    const varying float s0 = bitsToFloat(useHighOrderBits((uint32_t)(hash16_s6(scramble0) << 16u)));

    const varying float p = s0 + i * moebiusTransformationValues[idx];
    const varying float k = lambda * delta  / (i + i0);
    const varying float u = bitsToFloat(useHighOrderBits(triple32inc(scramble)));
    const varying float j = k*u;

    return mod1(p + j);
}


