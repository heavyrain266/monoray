// Copyright 2023-2024 DreamWorks Animation LLC
// SPDX-License-Identifier: Apache-2.0


#pragma once

#include "hash.h"
#include "Moebius.hh"
#include "Sample.h"

#include <scene_rdl2/render/util/BitUtils.h>

#include <cmath>

template <typename T>
constexpr T sqrt_pi = T(1.7724538509055160272981674833411451827975494561223871282138077898L);

namespace moonray {
namespace pbr {

inline float mod1(float x) noexcept
{
    return x - std::floor(x);
}

inline uint32_t rotate16(uint32_t n) noexcept
{
    return (n << 16) | (n >> 16);
}

inline Sample2D randomPoint(uint32_t i) noexcept
{
    using scene_rdl2::util::bitsToFloat;
    return Sample2D{bitsToFloat(triple32inc(i)), bitsToFloat(triple32inc(rotate16(i)))};
}

// From http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences
// The unreasonable effectiveness of quasi-random sequences
// Martin Roberts
inline Sample2D sampleR2(uint32_t i) noexcept
{
    // We define g as the generalized version of the golden ratio in d dimensions as the unique positive root
    // x^(d + 1) = x + 1
    // Here we're in 2 dimensions.
    constexpr float g = 1.324717957244746f; // special math constant
    Sample2D a{1.0f/g, 1.0f/(g*g)};
    return Sample2D{mod1(a.u * (i + 1)), mod1(a.v * (i + 1))};
}

// From http://extremelearning.com.au/a-simple-method-to-construct-isotropic-quasirandom-blue-noise-point-sequences/
// A simple method to construct isotropic quasi-random blue noise point sequences
// Martin Roberts
inline Sample2D jitteredR2(uint32_t n, uint32_t scramble) noexcept
{
    constexpr float lambda = 0.4f; // User parameter
    constexpr float delta = 0.76f; // Empirically optimized parameter

    // To jitter a point in the Fibonacci lattice of N points, you can offset the points as below:
    // p_i(x, y) + epsilon_i(delta_0/sqrt(N))
    // where delta_0 =~ 0.78
    // The author comes to the following value of i0 value by taking the mapping of two random variables to a disk of
    // radius r: epsilon_i(r) = (r*sqrt(u1) * cos(2*pi*u2), r*sqrt(ui) * sin(2*pi*u2))
    // With the coefficient of 1/sqrt(N) above, the author asserts that an infinite sequence can be substituted as
    // follows:
    // 1/sqrt(N) -> 1/(2 * sqrt(i - i0)), where i0 = 0.700 for i > 0
    // However, we're using zero-based indexing. Let
    // n = i - 1
    // Therefore
    // i - i0 = (n + 1) - i0 = n + (1 - i0)
    // Let n0 = 1 - i0
    // Taking n in [0, inf) leads to 1/(2 * sqrt(n + n0))
    constexpr float i0 = 0.700f; // Special math constant
    constexpr float n0 = 1.0f - i0;

    const Sample2D p = sampleR2(n);
    const Sample2D u = randomPoint(n + scramble);

    const float k = lambda * delta * sqrt_pi<float>/(4.0f * std::sqrt(n + n0));
    const Sample2D j{k*u.u, k*u.v};
    const Sample2D result{mod1(p.u + j.u), mod1(p.v + j.v)};
    return result;
}

// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/
inline float jitteredR1(uint32_t i, uint32_t scramble) noexcept
{
    using scene_rdl2::util::bitsToFloat;
    constexpr float lambda = 0.4f; // User parameter
    // Guessed parameter: TODO: we should do an analysis as done for 2D points here:
    // http://extremelearning.com.au/a-simple-method-to-construct-isotropic-quasirandom-blue-noise-point-sequences/
    constexpr float delta = 0.26f;
    constexpr float i0 = 1.010f;

    // We want three scramble values: the starting offset (s0), the hash index, and our random value. We could pass in
    // three separate values, but I worry about correlation since the hash values will be generated by the same sequence
    // identifier and the same hash function. Here we're still using the same initial value, but our hash functions are
    // at least unique. I am not worried about loss of precision in the floating point values (notably in s0), as these
    // only serve to add some additional randomness.
    const uint16_t scramble0(scramble & 0xFFFFu);
    const uint16_t scramble1((scramble >> 16u) & 0xFFFFu);

    static_assert(std::numeric_limits<decltype(scramble1)>::max() >= kMoebiusTransformationSize,
        "For a good distribution, we should be at least as big as our array");
    const uint32_t idx = hash16_s6(scramble1) % kMoebiusTransformationSize;
    const float s0 = bitsToFloat(static_cast<uint32_t>(hash16_s6(scramble0) << 16u));

    const float p = s0 + i * moebiusTransformationValues[idx];
    const float k = lambda * delta  / (i + i0);
    const float u = bitsToFloat(triple32inc(scramble));
    const float j = k*u;

    return mod1(p + j);
}

} // namespace pbr
} //namespace moonray


